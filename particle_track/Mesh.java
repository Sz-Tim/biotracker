/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package particle_track;

import ucar.nc2.NetcdfFile;
import ucar.nc2.Variable;
import ucar.ma2.*;

import java.io.IOException;

/**
 *
 * @author SA01TA
 */
public class Mesh {
    
    // Define the mesh type
    private String meshType;
    
    // Variables which are used in case of FVCOM triangular mesh
    private float[][] uvnode; // element centroid locations
    private float[][] nodexy; // element node locations
    private float[] depthUvnode; // depth at each element centroid
    private float[] depthNodexy; // depth at each mesh (xy)node
    private int[][] trinodes; // the nodes at the corners of each element
    private int[][] neighbours;
    private int[] openBoundaryNodes;
    private int[] boundaryNodes;
    
    // Variables used in the case of ROMS grid
    private float[][] lon_u;
    private float[][] lat_u;
    private float[][] lon_rho;
    private float[][] lat_rho;
    private float[][] depth_rho;
    
    // Variables used in all cases
    private float[] siglay;
    private float[][] convexHull;
    
    /**
     * Create a Mesh from a NetCDF file, and supplementary text files detailing 
     * the open and closed boundary nodes.
     * 
     * @param meshFilename
     */
    public Mesh(String meshFilename, String type)
    {
        System.out.println("Reading mesh file: "+meshFilename);
        
        meshType = type;
        if (type.equalsIgnoreCase("triangular") || type.equalsIgnoreCase("FVCOM"))
        {
            uvnode = IOUtils.readNetcdfFloat2D(meshFilename,"uvnode");
            nodexy = IOUtils.readNetcdfFloat2D(meshFilename,"nodexy");
            depthUvnode = IOUtils.readNetcdfFloat1D(meshFilename,"depthUvnode");
            depthNodexy = IOUtils.readNetcdfFloat1D(meshFilename,"depthNodexy");
            trinodes = IOUtils.readNetcdfInteger2D(meshFilename,"trinodes");
            neighbours = IOUtils.readNetcdfInteger2D(meshFilename,"nbe");
            siglay = IOUtils.readNetcdfFloat1D(meshFilename,"siglay");
            openBoundaryNodes = IOUtils.readNetcdfInteger1D(meshFilename,"boundaryNodesOpen");
            boundaryNodes = IOUtils.readNetcdfInteger1D(meshFilename,"boundaryNodesAll");
            // reduce node/element IDs in files generated by matlab by one (loops start at zero, not one as in matlab)
            for (int i = 0; i < trinodes.length; i++) {
                //System.out.println(bathymetry[i][0]);
                for (int j = 0; j < trinodes[1].length; j++) {
                    trinodes[i][j]--;
                    //System.out.printf("%d ",trinodes[i][j]);
                    if (neighbours[i][j] > 0) {
                        neighbours[i][j]--;
                    }
                }
                //System.out.printf("\n");          
            }
            for (int i = 0; i < openBoundaryNodes.length; i++) {
                openBoundaryNodes[i]--;
            }
            for (int i = 0; i < boundaryNodes.length; i++) {
                boundaryNodes[i]--;
            }

            System.out.println("neighbours: "+neighbours.length+" "+neighbours[1].length);
            
            float[][] uvnodeT = new float[uvnode[1].length][2];
            for (int i = 0; i < uvnode[1].length; i++)
            {
                uvnodeT[i][0] = uvnode[0][i];
                uvnodeT[i][1] = uvnode[1][i];
            }
            convexHull = ConvexHull.convexHull(uvnodeT);
            IOUtils.writeFloatArrayToFile(uvnodeT, "uvnode_FVCOM.dat", false);
            IOUtils.writeFloatArrayToFile(convexHull, "convexHull_FVCOM.dat", false);
        } 
        else if (type.equalsIgnoreCase("ROMS"))
        {
            lon_u = IOUtils.readNetcdfFloat2D(meshFilename,"lon_u");
            lat_u = IOUtils.readNetcdfFloat2D(meshFilename,"lat_u");
            lon_rho = IOUtils.readNetcdfFloat2D(meshFilename,"lon_rho");
            lat_rho = IOUtils.readNetcdfFloat2D(meshFilename,"lat_rho");
            siglay = IOUtils.readNetcdfFloat1D(meshFilename,"s_rho");
            
            float[][] x1 = IOUtils.reshapeFloat(lon_u, lon_u.length*lon_u[0].length, 1);
            float[][] y1 = IOUtils.reshapeFloat(lat_u, lat_u.length*lat_u[0].length, 1);
            float[][] xy = new float[lat_u.length*lat_u[0].length][2];
            for (int i = 0; i < lat_u.length*lat_u[0].length; i++)
            {
                xy[i] = new float[]{x1[i][0],y1[i][0]};
            }
            convexHull = ConvexHull.convexHull(xy);
            IOUtils.writeFloatArrayToFile(convexHull, "convexHull_ROMS.dat", false);
        }
        
        
       
    }
    
    /**
     * Public getter methods for each internal field
     */
    public float[][] getNodexy()
    {
        return nodexy;
    }
    public float[][] getUvnode()
    {
        return uvnode;
    }
    public float[] getDepthUvnode()
    {
        return depthUvnode;
    }
    public float[] getDepthNodexy()
    {
        return depthNodexy;
    }
    public int[][] getTrinodes()
    {
        return trinodes;
    }
    public int[][] getNeighbours()
    {
        return neighbours;
    }
    public float[] getSiglay()
    {
        return siglay;
    }
    public int[] getOpenBoundaryNodes()
    {
        return openBoundaryNodes;
    }
    public int[] getboundaryNodes()
    {
        return boundaryNodes;
    }
    public float[][] getConvexHull()
    {
        return convexHull;
    }
        
}

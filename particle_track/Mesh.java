/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package particle_track;

import ucar.nc2.NetcdfFile;
import ucar.nc2.Variable;
import ucar.ma2.*;

import java.io.IOException;

/**
 *
 * @author SA01TA
 */
public class Mesh {
    private float[][] uvnode; // element centroid locations
    private float[][] nodexy; // element node locations
    private float[] depthUvnode; // depth at each element centroid
    private float[] depthNodexy; // depth at each mesh (xy)node
    private int[][] trinodes; // the nodes at the corners of each element
    private int[][] neighbours;
    private float[] siglay;
    private int[] openBoundaryNodes;
    private int[] boundaryNodes;
    
    /**
     * Create a Mesh from a NetCDF file, and supplementary text files detailing 
     * the open and closed boundary nodes.
     * 
     * @param meshFilename
     */
    public Mesh(String meshFilename)
    {
        System.out.println("Reading mesh file: "+meshFilename);
        try
        {
            uvnode = IOUtils.readNetcdfFloat2D(meshFilename,"uvnode");
            nodexy = IOUtils.readNetcdfFloat2D(meshFilename,"nodexy");
            depthUvnode = IOUtils.readNetcdfFloat1D(meshFilename,"depthUvnode");
            depthNodexy = IOUtils.readNetcdfFloat1D(meshFilename,"depthNodexy");
            trinodes = IOUtils.readNetcdfInteger2D(meshFilename,"trinodes");
            neighbours = IOUtils.readNetcdfInteger2D(meshFilename,"nbe");
            siglay = IOUtils.readNetcdfFloat1D(meshFilename,"siglay");
//            float[] siglayTmp = IOUtils.readNetcdfFloat1D(meshFilename,"siglay");
//            for (int i = 0; i < siglayTmp.length; i++) // or sigvecTmp[0].length
//            {
//                siglay[i] = siglayTmp[0][i];
//            }
            openBoundaryNodes = IOUtils.readNetcdfInteger1D(meshFilename,"boundaryNodesOpen");
            boundaryNodes = IOUtils.readNetcdfInteger1D(meshFilename,"boundaryNodesAll");
            
            
            // reduce node/element IDs in files generated by matlab by one (loops start at zero, not one as in matlab)
            for (int i = 0; i < trinodes.length; i++) {
                //System.out.println(bathymetry[i][0]);
                for (int j = 0; j < 3; j++) {
                    trinodes[i][j]--;
                    //System.out.printf("%d ",trinodes[i][j]);
                    if (neighbours[i][j] > 0) {
                        neighbours[i][j]--;
                    }
                }
                //System.out.printf("\n");          
            }
            for (int i = 0; i < openBoundaryNodes.length; i++) {
                openBoundaryNodes[i]--;
            }
            for (int i = 0; i < boundaryNodes.length; i++) {
                boundaryNodes[i]--;
            }            
            
        }
        catch (IOException ioe) {
	    ioe.printStackTrace();
        } catch (InvalidRangeException ire) {
            ire.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }        
    }
    
    /**
     * Public getter methods for each internal field
     *  
     */
    public float[][] getNodexy()
    {
        return nodexy;
    }
    public float[][] getUvnode()
    {
        return uvnode;
    }
    public float[] getDepthUvnode()
    {
        return depthUvnode;
    }
    public float[] getDepthNodexy()
    {
        return depthNodexy;
    }
    public int[][] getTrinodes()
    {
        return trinodes;
    }
    public int[][] getNeighbours()
    {
        return neighbours;
    }
    public float[] getSiglay()
    {
        return siglay;
    }
    public int[] getOpenBoundaryNodes()
    {
        return openBoundaryNodes;
    }
    public int[] getboundaryNodes()
    {
        return boundaryNodes;
    }
    
    /**
     * Compute the convex hull of the the mesh (smallest possible perimeter 
     * encompassing all mesh elements)
     * 
     * @return 
     */
    public float[][] convexHull()
    {
        float[][] ch = new float[10][2];
        return ch;
    }
    
}

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package particle_track;

import ucar.nc2.NetcdfFile;
import ucar.nc2.Variable;
import ucar.ma2.*;

import java.awt.geom.Path2D;

import java.io.IOException;

import extUtils.ConcaveHull;

/**
 *
 * @author SA01TA
 */
public class Mesh {
    
    // Define the mesh type
    private String meshType;
    
    // Variables which are used in case of FVCOM triangular mesh
    private float[][] uvnode; // element centroid locations
    private float[][] nodexy; // element node locations
    private float[] depthUvnode; // depth at each element centroid
    private float[] depthNodexy; // depth at each mesh (xy)node
    private int[][] trinodes; // the nodes at the corners of each element
    private int[][] neighbours;
    private int[] openBoundaryNodes;
    private int[] boundaryNodes;
    
    // Variables used in the case of ROMS grid
    private float[][] lon_u;
    private float[][] lat_u;
    private float[][] lon_v;
    private float[][] lat_v;
    private float[][] lon_rho;
    private float[][] lat_rho;
    private float[][] depth_rho;
    private float[][] mask_u;
    private float[][] mask_v;
    
    private int[][] rangeUV = new int[2][2];
    
    // Variables used in all cases
    private float[] siglay;
    private float[][] convexHull;
    //private float[][] concaveHull;
    
    /**
     * Create a Mesh from a NetCDF file, and supplementary text files detailing 
     * the open and closed boundary nodes.
     * 
     * @param meshFilename
     */
    public Mesh(String meshFilename, String type)
    {
        System.out.println("Reading mesh file: "+meshFilename);
        
        meshType = type;
        if (type.equalsIgnoreCase("triangular") || type.equalsIgnoreCase("FVCOM"))
        {
            uvnode = IOUtils.readNetcdfFloat2D(meshFilename,"uvnode",null,null);
            nodexy = IOUtils.readNetcdfFloat2D(meshFilename,"nodexy",null,null);
            depthUvnode = IOUtils.readNetcdfFloat1D(meshFilename,"depthUvnode");
            depthNodexy = IOUtils.readNetcdfFloat1D(meshFilename,"depthNodexy");
            trinodes = IOUtils.readNetcdfInteger2D(meshFilename,"trinodes");
            neighbours = IOUtils.readNetcdfInteger2D(meshFilename,"nbe");
            siglay = IOUtils.readNetcdfFloat1D(meshFilename,"siglay");
            openBoundaryNodes = IOUtils.readNetcdfInteger1D(meshFilename,"boundaryNodesOpen");
            boundaryNodes = IOUtils.readNetcdfInteger1D(meshFilename,"boundaryNodesAll");
            // reduce node/element IDs in files generated by matlab by one (loops start at zero, not one as in matlab)
            for (int i = 0; i < trinodes.length; i++) {
                //System.out.println(bathymetry[i][0]);
                for (int j = 0; j < trinodes[1].length; j++) {
                    trinodes[i][j]--;
                    //System.out.printf("%d ",trinodes[i][j]);
                    if (neighbours[i][j] > 0) {
                        neighbours[i][j]--;
                    }
                }
                //System.out.printf("\n");          
            }
            for (int i = 0; i < openBoundaryNodes.length; i++) {
                openBoundaryNodes[i]--;
            }
            for (int i = 0; i < boundaryNodes.length; i++) {
                boundaryNodes[i]--;
            }

            System.out.println("neighbours: "+neighbours.length+" "+neighbours[1].length);
            
            float[][] uvnodeT = new float[uvnode[1].length][2];
            for (int i = 0; i < uvnode[1].length; i++)
            {
                uvnodeT[i][0] = uvnode[0][i];
                uvnodeT[i][1] = uvnode[1][i];
            }
            convexHull = ConvexHull.convexHull(uvnodeT);
            IOUtils.writeFloatArrayToFile(uvnodeT, "uvnode_FVCOM.dat", false);
            IOUtils.writeFloatArrayToFile(convexHull, "convexHull_FVCOM.dat", false);
            // This isn't working at the moment
            // At the very least, it's incredibly slow.
//            ConcaveHull ch2 = new ConcaveHull();
//            concaveHull = ch2.calculateConcaveHull(uvnodeT,3);
//            IOUtils.writeFloatArrayToFile(convexHull, "concaveHull_FVCOM.dat", false);
            
        } 
        else if (type.equalsIgnoreCase("ROMS"))
        {
            rangeUV[0][0] = 300;
            rangeUV[0][1] = 748;
            rangeUV[1][0] = 250;
            rangeUV[1][1] = 900;
            
            int[] origin = new int[]{rangeUV[0][0],rangeUV[1][0]};
            int[] shape = new int[]{rangeUV[0][1]-rangeUV[0][0],rangeUV[1][1]-rangeUV[1][0]};
            //int[] origin = null;
            //int[] shape = null;
            
            lon_u = IOUtils.readNetcdfFloat2D(meshFilename,"lon_u",origin,shape);
            lat_u = IOUtils.readNetcdfFloat2D(meshFilename,"lat_u",origin,shape);
            lon_v = IOUtils.readNetcdfFloat2D(meshFilename,"lon_v",origin,shape);
            lat_v = IOUtils.readNetcdfFloat2D(meshFilename,"lat_v",origin,shape);
            lon_rho = IOUtils.readNetcdfFloat2D(meshFilename,"lon_rho",origin,shape);
            lat_rho = IOUtils.readNetcdfFloat2D(meshFilename,"lat_rho",origin,shape);
            siglay = IOUtils.readNetcdfFloat1D(meshFilename,"s_rho");
            
            mask_u = IOUtils.readNetcdfFloat2D(meshFilename, "mask_u",origin,shape);
            mask_v = IOUtils.readNetcdfFloat2D(meshFilename, "mask_v",origin,shape);
            
            // Set the index limits. These are the ones to be used in the case of reading the full ROMS domain
            
            
            float[][] x1 = IOUtils.reshapeFloat(lon_u, lon_u.length*lon_u[0].length, 1);
            float[][] y1 = IOUtils.reshapeFloat(lat_u, lat_u.length*lat_u[0].length, 1);
            float[][] xy = new float[lat_u.length*lat_u[0].length][2];
            for (int i = 0; i < lat_u.length*lat_u[0].length; i++)
            {
                xy[i] = new float[]{x1[i][0],y1[i][0]};
            }
            convexHull = ConvexHull.convexHull(xy);
            IOUtils.writeFloatArrayToFile(convexHull, "convexHull_ROMS.dat", false);
            
            // List the corners to verify which way around the netCDF array is read in
            System.out.println("ROMS grid size: "+lon_u.length+" "+lon_u[0].length);
            System.out.println("Corner 1: "+lon_u[0][0]+" "+lat_u[0][0]);
            System.out.println("Corner 2: "+lon_u[lon_u.length-1][0]+" "+lat_u[lon_u.length-1][0]);
            System.out.println("Corner 3: "+lon_u[lon_u.length-1][lon_u[0].length-1]+" "+lat_u[lon_u.length-1][lon_u[0].length-1]);
            System.out.println("Corner 4: "+lon_u[0][lon_u[0].length-1]+" "+lat_u[0][lon_u[0].length-1]);
            // From this we can see that 
            // increasing first index => increasing longitude
            // increasing second index => decreasing latitude
            
            // The following isn't working at the moment.
            // At the very least, it's incredibly slow.
//            ConcaveHull ch2 = new ConcaveHull();
//            concaveHull = ch2.calculateConcaveHull(xy,3);
//            IOUtils.writeFloatArrayToFile(convexHull, "concaveHull_ROMS.dat", false);
        }
    }
    
    /**
     * Public getter methods for each internal field
     */
    public float[][] getNodexy()
    {
        return nodexy;
    }
    public float[][] getUvnode()
    {
        return uvnode;
    }
    public float[] getDepthUvnode()
    {
        return depthUvnode;
    }
    public float[] getDepthNodexy()
    {
        return depthNodexy;
    }
    public int[][] getTrinodes()
    {
        return trinodes;
    }
    public int[][] getNeighbours()
    {
        return neighbours;
    }
    public float[][] getLonU()
    {
        return lon_u;
    }
    public float[][] getLatU()
    {
        return lat_u;
    }
    public float[][] getLonV()
    {
        return lon_u;
    }
    public int[][] getRange()
    {
        return rangeUV;
    }
    public float[][] getLatV()
    {
        return lat_u;
    }
    public float[] getSiglay()
    {
        return siglay;
    }
    public int[] getOpenBoundaryNodes()
    {
        return openBoundaryNodes;
    }
    public int[] getboundaryNodes()
    {
        return boundaryNodes;
    }
    public float[][] getConvexHull()
    {
        return convexHull;
    }
    public String getType()
    {
        return meshType;
    }
    
    /**
     * Create a Path2D object from a list of x,y points
     * @param points
     * @return 
     */
    public static Path2D.Float pointsToPath(float[][] points)
    {
        if (points[0].length != 2)
        {
            System.err.print("Array provided to pointsToPath must have second dimension = 2");
        }
        Path2D.Float path = new Path2D.Float();
        path.moveTo(points[0][0], points[0][1]);
        for (int i = 1; i < points.length; i++)
        {
            path.lineTo(points[i][0], points[i][1]);
        }
        path.closePath();
        
        return path;
    }
    
    /**
     * Is a specific location within the mesh convex hull?
     * Note that this does not guarantee the point is within a mesh element, so we
     * should normally find the nearest/containing node or element in addition to the
     * mesh ID.
     * 
     * @param mesh
     * @param xy
     * @return 
     */
    public boolean isInMesh(double[] xy)
    {
        Path2D.Float cHull = Mesh.pointsToPath(this.getConvexHull());
        boolean inMesh = cHull.contains(xy[0],xy[1]);
        return inMesh;
    }
    
    
}

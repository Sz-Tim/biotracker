/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package particle_track;

import java.lang.Object;

/**
 *
 * @author tomdude
 */
public class Particle_track {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
    
        System.out.println("Starting particle tracking program\n");

        // read in velocity field data
        // directory for file to read
        String dir="fvcom_output\\110817_1306_943node_tideriv_its";

        System.out.println("Running get_grid2\n");
        
        // get_grid2 reads in data from current_0001.nc to have node and element
        // data. Maybe change java version so that it returns a "mesh" structure?
        // OR - just create the centroids directly by calling a function here that 
        // reads from the netcdf file
        //Mesh mesh = get_grid2(dir);
        //System.out.println("Running plot_usmean_onz\n");
        //plot_usmean_onz(dir);

        System.out.println("Reading in data\n");
        String file= "Z:\\"+dir+"\\output\\netcdf\\current_0001.nc";

        int M=length(nc_varget(file,"x")); //number of nodes
        int N=length(nc_varget(file,"partition")); //number of triangles
        
        // will this work directly? check netcdf file variables
        // TODO make function nc_varget -- same data as mesh.uvnodes
        // TODO actually need to interpolate using x,y and nv (list of corner nodes for each element)
        int nv[] = new int[N];
        // TODO the element centroids
        double centroids[][] = makeCentroidXY(file);
        
        // the node coordinates 
        double nodex[]=nc_varget(file,"x");
        double nodey[]=nc_varget(file,"y");

        // TODO u and v are 3d in netcdf file - read in correctly
        double u=nc_varget(file,"u");
        double v=nc_varget(file,"v");

        // setup farms and boundary
        int tstart=1000;
        int tmax=3000;
        int nparts=500;
        double dt=621;

        double startlocs[][] = setupStartLocations();

        double islandx[] = new double[6];
        double islandy[] = new double[6];
        islandx[0] = nodex[655]; islandy[0] = nodey[655];
        islandx[1] = nodex[642]; islandy[1] = nodey[642];
        islandx[2] = nodex[641]; islandy[2] = nodey[641];
        islandx[3] = nodex[629]; islandy[3] = nodey[629];
        islandx[4] = nodex[640]; islandy[4] = nodey[640];
        islandx[5] = nodex[656]; islandy[5] = nodey[656];
        Polygon island = new Polygon(islandx,islandy,6);

        // make a list of boundary nodes ("outline" of the loch)
        // TODO write setup_bnodes in java
        int bnodes[]=list_bnodes();
        double bnodesx[] = new double[bnodes.length];
        double bnodesy[] = new double[bnodes.length];

        int startcells[] = new int[startlocs[0].length];
        for (int i = 0; i < startcells.length; i++)
        {
            startcells[i]=0;
            // TODO rewrite whichelement in java - does this need to allow a list of elements to be read in?
            startcells[i]=whichelement(startlocs[0][i],startlocs[1][i],
                    nodex,nodey,centroids);
            // TODO check whether an in polygon method is available in java
            int inmesh=inpolygon(startlocs[0][i],startlocs[1][i],bnodes);
            int inisland=inpolygon(startlocs[0][i],startlocs[1][i],island);
            if (startcells[i]==0)
            {
                System.out.printf("INITIAL POINT %d OUTSIDE MESH\n",i);
            }
            //System.out.println("//d //d //d ",startcells(i),inmesh,inisland);
        }

        // make an array of neighbouring elements to each element
        // TODO rewrite neighbourcells
        //neighbours=neighbourcells(centroids);

        // the particle tracking
        System.out.println("Particle tracking starting....\n");
        

        // ----------------------- loop 1 = farm sites ---------------------------
        // TODO write one output file per farm site
        int veltype=3;
        for (int j = 0; j < startlocs.length; j++)
        //for j=1
        {
            // an array to save the locations of tracked particles
            // TODO maybe just write these to a file every e.g. 100 steps and write over?
            // TODO save to file after each separate farm run has been completed.
            double locs[][][] = new double[tmax][nparts][2];
            int celllocs[][] = new int[tmax][nparts];
            // an array to save the number of "particle-timesteps" in each cell
            int psteps[] = new int[N];
            for (int i = 0; i < N; i++)
                {
                    psteps[i]=0;
                }
          
            // set initial particle locations
            double xstart=startlocs[j][1];
            double ystart=startlocs[j][2];
            System.out.printf("start location = %d %d\n",xstart,ystart);
            int inside=inPolygon(xstart,ystart,bnodes);
            if (inside==0)
            {
                System.out.println("INITIAL POINT OUTSIDE MESH\n");
            }
            Particle particles[] = new Particle[nparts];
            //particles(1).x
            //particles(1).y
            for (int i = 0; i < nparts; i++)
            {//System.out.println("PARTICLE //d\n",i)
               particles[i]= new Particle(xstart,ystart);
               particles[i].setElem(whichElement(xstart,ystart,nodex,nodey,centroids);
            }

            System.out.println("Starting time loop\n");
            // ------------------- loop 2 = timestep ----------------------------

            for (int tt = tstart; tt < tmax; tt++)
            {
                if (tt%100==0)
                {
                    System.out.println("//d ",tt); 
                }

                //System.out.println("TIMESTEP //d\n",tt); 
                // velocity in surface layer at time tt..........
                // if tmax is greater than the length of the velocity vectors in the
                // netcdf file, get velocities by cycling through the last two M_2 
                // tide cycles (assuming DTI=6.21 (DTE=0.621) and CDF_INT=100)
                if (tt<size(u,1))
                    uchunk=squeeze(u(tt,1,:));
                    vchunk=squeeze(v(tt,1,:));
                else
                    index=size(u,1)-144+mod(tt-size(u,1),144);
                    uchunk=squeeze(u(index,1,:));
                    vchunk=squeeze(v(index,1,:));
                end
                velocities=[uchunk vchunk];
                //size(uchunk)
                //size(vchunk)

                // --------------- loop 3 = particle ----------------------------
                //System.out.println("hello");
                for i=1:nparts 
                    //System.out.println("PARTICLE //d\n",i);
                    if (veltype==1)
                        // 1. find neighbouring cells to compute velocity
                        closest=nearest_centroid(particles(i).x,particles(i).y,centroids);
                        //closest=whichelement(particles(i).x,particles(i).y,(1:length(grid.mesh2.trinodes)),grid.mesh2.nodexy,grid.mesh2.trinodes);
                        // 2. calculate velocity applied to particle
                        water_U=velocities(closest,1);
                        water_V=velocities(closest,2);
                        //System.out.println("water u = //e v = //e\n",water_U,water_V);
                    end
                    if (veltype==2)
                        [water_U,water_V,closest]=velocity_nearest5centroids(particles(i),centroids,velocities);
                        //System.out.println("water u = //e v = //e\n",water_U,water_V);
                    end
                    // 
                    if (veltype==3)
                        // look in the current element and its neighbours
                        //System.out.println("hello");
                        //i
                        //elemPart(i)
                        //neighbours(elemPart(i),:)
                        //index=transpose(find(neighbours(elemPart(i),:)));
                        elemPart(i)=whichelement(particles(i).x,particles(i).y,neighbours(elemPart(i),:),grid.mesh2.nodexy,grid.mesh2.trinodes);
                        //centroids(neighbours(elemPart(i),:))
                        //posscentroids=centroids(index,:);
                        //elemPart(i)=nearest_centroid(particles(i).x,particles(i).y,posscentroids);
                        // if this fails, look in all elements
                        if (elemPart(i)==0)
                            elemPart(i)=whichelement(particles(i).x,particles(i).y,(1:length(grid.mesh2.trinodes)),grid.mesh2.nodexy,grid.mesh2.trinodes);
                            //elemPart(i)=nearest_centroid(particles(i).x,particles(i).y,centroids);
                        end
                        if (elemPart(i)==0)
                            inside=inpolygon(particles(i).x,particles(i).y,bnodes(:,1),bnodes(:,2));
                            inisland=inpolygon(particles(i).x,particles(i).y,island(:,1),island(:,2));
                            if (inside==1 && inisland==0)
                                thenearest=nearest_centroid(particles(i).x,particles(i).y,centroids)
                                iamin=whichelement(particles(i).x,particles(i).y,(1:length(grid.mesh2.trinodes)),grid.mesh2.nodexy,grid.mesh2.trinodes)
                                elemPart(i)=thenearest;
                            else
                                System.out.println("\nERROR: Particle escaped region. x=//.4e y=//.4e\n",particles(i).x,particles(i).y);
                            end
                        end
                        water_U=velocities(elemPart(i),1);
                        water_V=velocities(elemPart(i),2);
                        closest=elemPart(i);
                    end
                    celllocs(tt,i,j)=closest;
                    psteps(closest,j)=psteps(closest,j)+1;

                    //[water_U,water_V]=calc_vel1(particles(i),[uchunk vchunk]);
                    // 3. Calculate diffusion    
                    //rand("twister",sum(100*clock)); //resets it to a different state each time.
                    diff_X = sqrt(6*dt);
                    diff_Y = sqrt(6*dt);    //+/- is random so direction doesn"t matter
                    // 4. update particle location
                    newlocx=particles(i).x+dt*water_U+normrnd(0,diff_X); // simplest possible "Euler"
                    newlocy=particles(i).y+dt*water_V+normrnd(0,diff_Y);
                    // inpolygon
                    inside=inpolygon(newlocx,newlocy,bnodes(:,1),bnodes(:,2));
                    inisland=inpolygon(newlocx,newlocy,island(:,1),island(:,2));
                    if (inside==1 && inisland==0)             
                        particles(i).x=newlocx;
                        particles(i).y=newlocy;
                    end
                    // save locations for plotting later
                    //System.out.println("newloc = //f //f\n",particles(i).x,particles(i).y)
                    locs(tt,i,1,j)=particles(i).x;
                    locs(tt,i,2,j)=particles(i).y;
                    // 5. do mortality calculations etc.

                end
            end
            toc
        end
        //profile viewer
        //p = profile("info");
        //profsave(p,"profile_results")
        // scale psteps
        tot_psteps=tmax*nparts;
        for j=1:length(startlocs)
            for i=1:N
                psteps2(i,j)=psteps(i,j)/tot_psteps;
            end
        end
       
    }

    public double[][] setupStartLocations()
    {
        int nsites = 9;
        double startlocs[][]= new double[2][nsites];
        
        startlocs[0][0]=357420; startlocs[1][0]=6217200; 
        startlocs[0][1]=361834; startlocs[1][1]=6223063;
        startlocs[0][2]=353078; startlocs[1][2]=6206339;
        startlocs[0][3]=354246; startlocs[1][3]=6194759; 
        startlocs[0][4]=352745; startlocs[1][4]=6201735;
        startlocs[0][5]=348880; startlocs[1][5]=6199380;
        startlocs[0][6]=354969; startlocs[1][6]=6193169;
        startlocs[0][7]=348606; startlocs[1][7]=6204475;
        startlocs[0][8]=352401; startlocs[1][8]=6190933;
        // non-fishfarms
//        double startlocs[][]=[354500 6188000; 
//            355200 6192000;
//            350000 6197000;
//            352800 6196000; 
//            348000 6209000;
//            354000 6204000;
//            357000 6213000;
//            360000 6219000;
//            370000 6227000];
        // "hypothetical" fishfarm used for SAMS newsletter
        //fishfarms(1,1)=351000;
        //fishfarms(1,2)=6195000;
        //"2" is Minard
        //"7" is Portavadie
        return startlocs;
    }

    public double[][] makeCentroidXY()
    {
    }

    public void setupOutput()
    {

    }

    public void writeOutput()
    {
    
    }
    
    public double nc_varget(String filename, String variable)
    {

    }

}
